#!/usr/bin/env python
# encoding: utf-8
'''
transdecoder_to_genome -- Convert outputted transcript coordinate to the appropriate genome coordinates.

transdecoder_to_genome is a tool for converting transcript coordinates to appropriate genome coordinate.
Expects the genome gff3 as input, along with the file transcripts file.

@author:     Steven Hill
            
@copyright:  2013 Donald Danforth Plant Science Center. All rights reserved.
            
@contact:    shill@danforthcenter.org
'''

import sys 
import os
import traceback

from optparse import OptionParser

__all__ = []
__version__ = 0.1
__date__ = '2013-07-25'
__updated__ = '2013-07-25'

PROFILE = 0

def main(argv=None):
    '''Command line options.'''
    
    program_name = os.path.basename(sys.argv[0])
    program_version = "v0.1"
    program_build_date = "%s" % __updated__
 
    program_version_string = '%%prog %s (%s)' % (program_version, program_build_date)
    #program_usage = '''usage: spam two eggs''' # optional - will be autogenerated by optparse
    program_longdesc = '''''' # optional - give further explanation about what the program does
    program_license = "Copyright 2013 Donald Danforth Plant Science Center                                           \
                Licensed under the Apache License 2.0\nhttp://www.apache.org/licenses/LICENSE-2.0"

    if argv is None:
        argv = sys.argv[1:]
        # setup option parser
        parser = OptionParser(version=program_version_string, epilog=program_longdesc, description=program_license)
        parser.add_option("-r", "--referencegff", dest="referencegff", help="Reference gff to use <FILE>", metavar="FILE")
        parser.add_option("-b", "--best_cand", dest="bestcandgff", help="Transdecoder best_candidates.eclipsed_orfs_removed.gff3 generated file <FILE>", metavar="FILE")
    
        # process options
        (opts, args) = parser.parse_args(argv)
        rg,bcg,rf = None,None,None
        if opts.referencegff:
            rg = opts.referencegff
        if opts.bestcandgff:
            bcg = opts.bestcandgff
        if opts.referencefasta:
            rf = opts.referencefasta
            print rf
        if rg == None or bcg == None:
            print "Expects three arguments."
            parser.print_help()
            return 2

        convert_trans_to_genome_objects(rg, bcg)
    
"""
    Takes the original gff3 and the transdecoder output, best_candidate.orf.gff3. Creates a new gff containing each CDS in genome
    coordinates instead of local coordinates. If there is more than one Open reading frame for each transcript, it will automatically 
    choose the best ORF. This function removes the partial tags from each ORF.
    
    choose_best tells the system to automatically choose the best transcript for each locus. 

"""
            
def convert_trans_to_genome_objects(original_gff, best_cands, choose_best = True):
    bc_lookup = {}
    with open(best_cands, "r") as bc:
        for line in bc:
            try:
                gene = Transcript(line)
            except:
                continue
            if gene.getLabel() == "gene":
                try:
                    bc_lookup[gene.parent].append(gene)
                except KeyError:
                    bc_lookup[gene.parent] = []
                    bc_lookup[gene.parent].append(gene)
    with open(original_gff, "r") as og:
        last_trans = None
        cur_locus = None
        for line in og:
            try:
                cur_gene = GFFLine(line)
            except Exception, e:
                continue
            if cur_gene.getLabel() == "locus":
                if cur_locus != None:
                    if choose_best:
                        cur_locus.chooseBest()
                    cur_locus.printLines()
                cur_locus = Locus(cur_gene.lines[1])
            if cur_gene.getLabel() == "exon":
                last_trans.addExon(Exon(cur_gene.lines[1]))                
            elif "transcript" == cur_gene.getLabel() or "mRNA" == cur_gene.getLabel():
                #current is a transcript, so process the complete set, which is the previous transcript
                if last_trans != None and len(last_trans.exons) > 0:
                    try:
                        best = None
                        for trans in bc_lookup[last_trans.getName()]:
                            if best == None:
                                best = trans
                            if trans > best:
                                best = trans
                        if best.strand == "-":
                            last_trans.switchDirections()
                        last_trans.setLength(len(best))
                        last_trans.setPartial(best.partial)
                        best = Exon(best.lines[1]) #cast it to an exon
                        transcript = best.getDicFormat(best.parent)
                        genome_exon_list = last_trans.getExonDicList()
                        #maybe add another method for this..
                        exons = {'start': last_trans.start, 'stop': last_trans.stop, 'name': last_trans.getName(), 'exons': genome_exon_list}
                        try:
                            #get genome coordinates
                            cds = build_coordinates(exons, transcript)
                            if len(cds) == 0:
                                raise Exception("CDS empty")
                            for exon in last_trans.exons:
                                for seq in cds:
                                    #if it is a part of or equal to this exon write it                                        
                                    if seq['start'] >= exon.start and seq['stop'] <= exon.stop:
                                        #change exon to CDS, put the CDS start at the start position and CDS end at end position.
                                        fin = exon.lines[1].replace('exon', 'CDS').replace(str(exon.start),str(seq['start'])).replace(str(exon.stop),str(seq['stop']))
                                        last_trans.addCDS(Exon(fin))
                                        break 
                        except Exception as e:
                            #error in the reading, usually means nothing found.
                            pass
                    except KeyError as e:
                        pass #not found in CDS list
                if last_trans != None:
                    cur_locus.addTranscript(last_trans)
                last_trans = Transcript(cur_gene.lines[1])
            else: 
                #print all other lines?
                pass#print line.strip()
    
"""
    This function should be responsible for building the genome coordinates and the exon coordinates and performing
    a translation from exon coordinates to genome coordinates.
    
    Exceptions will be raised if the names do not match or if one of the transcript coordinates is invalid. The definition
    of coordinates expected are to start at 1, and to go UNTIL the last number. So a reading frame of length one would have the
    same start as end.
    
    @param gene = {'start': '100', 'stop': '400', 'name': 'gene1', 'exons': ({'start': 100, 'stop': 149}, {'start': 200, 'end': 249}, {'start': 300, 'stop': 400})}    
    @param transcript = {genename: (start, stop)}
    
    @returns gene_genome = <cds> ({"start":start, "stop":stop}, {"start":start,"stop":stop}, {"start":start,"stop":stop}... )
"""    
def build_coordinates(gene, transcript):
        if transcript['start'] < 1:
            raise Exception("Transcript Start is less than 1.")
        if transcript['stop'] < transcript['start']:
            raise Exception("Transcript Stop is less than start.")
        if (gene['name'] != transcript['name']):
            err = "Gene names do not match. " + str(gene['name'])+ " " + str(transcript['name'])
            raise Exception(err)
        #to build our list use range and add one to the end because range is exclusive and gff3 is inclusive
        genome_coords = []
        gene_list = []
        for exons in gene['exons']:
            genome_coords += range(exons['start'], exons['stop'] + 1)
            gene_list.append(range(exons['start'], exons['stop'] + 1))
        start, stop = None, None
        try:
            for genes in gene_list:
                try:
                    end = genome_coords[transcript['stop'] - 1]
                except IndexError:                    
                    end = genome_coords[-1]
                if genome_coords[transcript['start']-1] in genes:
                    start = gene_list.index(genes)
                    start_idx = genes.index(genome_coords[transcript['start'] - 1] )
                if end in genes:
                    stop = gene_list.index(genes)
                    stop_idx = genes.index(end)
        except IndexError:
            tb = traceback.format_exc()
            print >> sys.stderr, tb
            print >> sys.stderr, transcript['stop'] - 1, len(genome_coords)- 1, transcript['stop'] - len(genome_coords) , (transcript['stop'] - 1) % 3, transcript['name']
        cds = []

        for i in range(start, stop+1):
            cur_cds = gene['exons'][i]
            if i == start:
                cur_cds['start'] = gene_list[start][start_idx]
            elif i == stop:
                cur_cds['stop'] = gene_list[stop][stop_idx]
            if start == stop: #case where they are the same
                cur_cds['stop'] = gene_list[stop][stop_idx]
            cds.append(cur_cds) 
        return cds  
"""
    Base class for a line in a gff3 file. Responsible for parsing the lines, building dictionary format, handling strandedness.
    Before we know what something is it will be instantiated as a GFFLine. Also contains the original line and a parsed version of
    that line.
"""

class GFFLine():
    start = ""
    stop = ""
    lines = None
    strand = None
    parent = None
    def __init__(self, line):
        self.ParseHeader(line)
        
    def __len__(self):
        if self.stop == None or self.start == None or self.stop - self.start < 1:
            raise Exception("Improperly initialized. Invalid start and end")
        return self.stop - self.start
    
    def __str__(self):
        return self.lines[1]
    
    def __contains__(self, key):
        if key in self.lines[1]:
            return True
        else: 
            return False     
    def getLabel(self):
        return self.lines[0][2]
    
    def ParseHeader(self, line):
        linearr = line.split()
        if len(linearr) < 8:
            raise Exception("Line does not contain valid format.\n" + line)
        self.lines = [linearr, line]
        self.start = int(linearr[3])
        self.stop = int(linearr[4])
        self.parent = linearr[0]
        if self.start >= self.stop:
            raise Exception("Error in input, start must be less than stop: "+ " ".join(linearr[3:5]))
        if "+" in line: self.strand = "+"
        else: self.strand = "-"
    
    def getDicFormat(self):
        raise Exception("GFFLine should never call getDicFormat. Check your typing.")
        return {'name': self.getLabel(), 'start': self.start, 'stop': self.stop}
    """
    Returns self for convenience.
    Switched from + to - and - to +. Also updates the lines.
    """
    def switchStrand(self):
        if self.strand == "+":
            self.strand = "-"
            self.lines[0][6] = self.strand
            self.lines[1] = self.lines[1].replace("+", self.strand)
            return self
        if self.strand == "-":
            self.strand = "+"
            self.lines[0][6] = self.strand
            self.lines[1] = self.lines[1].replace("-", self.strand)
            return self
"""
    Child class of GFFLine that is for locus. Locus are special because they are the top of the heirarchy and may contain transcripts.
    This class is also responsible for printing all of the child transcripts and their associated exons/CDS
"""
class Locus(GFFLine):
    transcripts = None
    transcript_lines = None
    name = ""
    def __init__(self,line):
        GFFLine.__init__(self, line)
        self.transcript_lines = []
        self.transcripts = []
        self.name = self.lines[0][8].split("=")[1].split(";")[0]

    def addTranscriptLine(self, line):
        self.transcript_lines.append(line)
        
    def addTranscript(self, trans):
        self.transcripts.append(trans)
    
    def getName(self):
        return self.name
    
    def printLines(self):
        print self.lines[1],
        for trans in self.transcripts:
            if len(trans.CDS) != 0:
                print trans,
                for exon in trans.exons:
                    print exon,
                    for cds in trans.CDS:
                        if cds.start >= exon.start and cds.stop <= exon.stop:
                            print cds,
                            break
    def chooseBest(self):
        best = None
        for trans in self.transcripts:
            if trans > best:
                best = trans
        self.transcripts = [best]

"""
Contains a list of exons, and overridden operators for Greater Than, Less Than, Equals.
Contains various function on the set of exons in this transcript. Also includes a name function
"""
class Transcript(GFFLine): 
    exons = None
    partial = None
    name = None
    CDS = None
    def __init__(self, line):
        GFFLine.__init__(self, line)
        self.exons = []
        self.CDS = []
        self.length = None
        if "partial" in self:  self.partial = "partial"
        elif "internal" in self: self.partial = "internal"
        else: self.partial = "complete"
        self.name = self.lines[0][8].split("=")[1].split(";")[0]
        
    def setPartial(self, partial):
        self.partial = partial
    
    def __len__(self):
        if self.length != None:
            return self.length
        else:
            return GFFLine.__len__(self)
    def getName(self):
        return self.name
    
    def setLength(self, length):
        self.length = length
        
    def addExon(self, exon):
        if not isinstance(exon, Exon):
            raise Exception("Passed is not of type exon. Type Exon expected.")
        self.exons.append(exon)
        
    def addCDS(self, CDS):
        if not isinstance(CDS, Exon):
            raise Exception("Passed is not of type exon. Type Exon expected.")
        self.CDS.append(CDS)
    def getExonDicList(self):
        lst = []
        for exon in self.exons:
            lst.append( exon.getDicFormat() )
        return lst
    def getDicFormat(self):
        return {'name': self.name, 'start': self.start, 'stop': self.stop}
    
    def switchDirections(self):
        self.switchStrand()
        new_exons = []
        for exon in self.exons:
            new_exons.append(exon.switchStrand())
        self.exons = new_exons
        return True
    
    def __gt__(self, b):
        if b == None:
            return True
        if self.isComplete() and not b.isComplete():
            return True
        if b.isComplete() and not self.isComplete():
            return False
        if len(self) > len(b):
            return True
        if len(b) > len(self):
            return False
        return False
    def __lt__(self, b):
        if b == None:
            return False
        if self.isComplete() and not b.isComplete():
            return False
        if b.isComplete() and not self.isComplete():
            return True
        if len(self) > len(b):
            return False
        if len(b) > len(self):
            return True
        return False
    def __eq__(self, b):
        #so brave
        if not self > b and not self < b:
            return True
    def isComplete(self):
        if "complete" in self.partial:
            return True
        else: 
            return False
        
"""
Overrides getDicFormat to use the parent as the name
"""
class Exon(GFFLine):
    def __init__(self, line):
        GFFLine.__init__(self, line)
    def parseName(self):
        self.name = self.lines[0][8].split("=")[1].split(";")[0]

    def getDicFormat(self, name=None):
        if name == None:
            self.parseName()
        else:
            self.name = name
        return {'name': self.name, 'start': self.start, 'stop': self.stop}


if __name__ == "__main__":
    if PROFILE:
        import cProfile
        import pstats
        profile_filename = 'transdecoder_to_genome_profile.txt'
        cProfile.run('main()', profile_filename)
        statsfile = open("profile_stats.txt", "wb")
        p = pstats.Stats(profile_filename, stream=statsfile)
        stats = p.strip_dirs().sort_stats('cumulative')
        stats.print_stats()
        statsfile.close()
        sys.exit(0)
    sys.exit(main())
